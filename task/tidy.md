# scheme-tidy

В этой подзадаче не нужно реализовывать никаких новых функций языка scheme. Все, что требуется - добиться правильной очистки памяти.

## Mark-and-Sweep

Мы напишем сборщик мусора, работающий по алгоритму [Mark-and-Sweep](https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/) - вкратце, он поддерживает граф связей объектов, а при очистке обходит его, начиная с корня, помечает достижимые объекты, затем удаляет непомеченные. Таким образом, компоненты связности, целиком недостижимые из корня, будут удалены - при использовании `std::shared_ptr` такого достичь нельзя.

Как такое написать? Заведем единый класс, который будет содержать всю логику создания и очистки - назовем его `Heap`. `Heap` должен уметь создавать (`Make`) объекты разных типов (но как проверить, что создаются только наследники `Object`?), а также обходить граф объектов и удалять недостижимые. Сделайте интерфейс ваших объектов таким, чтобы их нельзя было создать иначе, как из `Heap::Make`. Еще вам иногда будет нужно клонировать объект - заведите специальный метод `Clone`, который будет уметь правильно клонировать объект с зависимостями, и удалите конструкторы копирования.

Также поддержите логику с зависимостями в `Object` - каждый `Object` должен знать список своих зависимостей, уметь добавлять зависимость и удалять ее. Оформите это как protected-методы `AddDependency` и `RemoveDependency`, не обращайтесь к списку нигде кроме них. Подумайте, что будет зависимостями у числа, у boolean, у пары, у лямбды?

Что будет происходить при обходе графа? Что будет являться корнем, от которого нужно выяснить достижимость? Напишите в `Object` метод `Mark`, который будет помечать зависимости объекта как достижимые, и рекурсивно вызывать `Mark` от них. Метод `Mark` не должен быть доступен публично, он должен вызываться только внутри `Heap` и наследников `Object`.

Воспользуйтесь известным вам паттерном, чтобы не передавать всюду ссылку на `Heap` - ведь создавать объекты может быть нужно в разных частях программы.
